open Definition
open Constant
open Util

(* set element at index i to e. preserves order of list*)
let list_update_elem (i : int) (e : 'a) (lst : 'a list) : 'a list = 
  let rec helper i l1 current l2 = 
    if i = 0 then List.rev_append l1 (e::l2)
    else match l2 with 
    | [] -> failwith "<list_update_elem> index is out of range"
    | h::t -> helper (i-1) (current::l1) h t
  in 
    match lst with 
    | [] -> failwith "<list_update_elem> lst is empty"
    | h::t -> helper i [] h t

(* update [inter_list] to add settlement for player [color] at [point] of type [settl_type]  *)
let add_settlement point color settl_type inter_list = 
  list_update_elem point (Some (color, settl_type)) inter_list

(* update [road_list] to add road on [line] for player [color]  *)
let add_road line color road_list = (color, line)::road_list

(* returns number of towns on the board *)
let num_towns inter_list =
  let f x = (not (is_none x)) && (snd (get_some x) = Town) in 
  list_count f inter_list

(* returns number of cities on the board *)
let num_cities inter_list =
  let f x = (not (is_none x)) && (snd (get_some x) = City) in 
  list_count f inter_list

(* true iff a line exist between p1 and p2 *)
let is_valid_line (p1, p2) = List.length (List.filter (fun x -> x = p2) (adjacent_points p1)) = 1

(* true iff p1 is at least two roads away from any other settlement and p1 does not have a settlement*)
let is_valid_town inter_list p1 = 
  let rec helper = function 
    | [] -> true
    | h::t -> is_none (List.nth inter_list h) && helper t
  in
    is_none (List.nth inter_list p1) && helper (adjacent_points p1)

(* add two resources *)
let sum_recources resource1 resource2 = map_cost2 ( + ) resource1 resource2

(* return the hexes corspanding to the a pieces in plst *)
let get_hexes (plst : piece list) (hlst : hex list): hex list = 
  let rec helper out plst hlst nth = 
    match plst, hlst, nth with 
    | [], _, _ -> out
    | ph::pt, hh::ht, n -> begin
      if ph = n then helper (hh::out) pt ht (n+1) 
      else helper out plst ht (n+1)
    end
    | _ -> failwith "<get_hexes> entries in plst don't map to entries in hlst"  
  in 
    helper [] (List.sort (compare) plst) hlst 0

(* gen num amount of resources from given hex or zero resources if tar = Desert *)
let gen_hex_resource (num : int) ((tar, _) : hex)  = 
  let res = resource_of_terrain tar in 
  if is_none res then (0,0,0,0,0)
  else map_cost (fun x-> x *num ) (single_resource_cost (get_some res))

(* return the sum of num amount of resources generated by each hexe 
  that's neighbors p and not accupied by robber *)
let gen_all_resources p num hex_list robber = 
  let adj = List.filter (fun x -> x <> robber) (adjacent_pieces p) in
  let hexes = get_hexes adj hex_list in 
  let f acc elem = sum_recources acc (gen_hex_resource num elem) in
  List.fold_left f (0,0,0,0,0) hexes  

(* add resources r to the inventory of player c *)
let add_resources_to_player c r player_list = 
  let f ((color, (inventory, cards), trophies) as pl) = 
    if color = c then ((color, (sum_recources inventory r, cards), trophies)) else pl
  in
    List.map f player_list 