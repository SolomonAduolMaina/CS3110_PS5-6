open Definition
open Constant
open Util

(* return a tuple (x, xs) where x is the player with 
  color c and xs is a list of the rest of the player  *)
let get_player c player_list = 
  let (x, xs) = List.partition (fun (color,_,_) -> color = c) player_list
  in 
    match x with 
    | [y] -> (y, xs)
    | _ -> failwith "<get_player> player with the color provided
       is not present (or present multiple times) in player_list" 

(* set element at index i to e. preserves order of list*)
let list_update_elem (i : int) (e : 'a) (lst : 'a list) : 'a list = 
  let rec helper i l1 current l2 = 
    if i = 0 then List.rev_append l1 (e::l2)
    else match l2 with 
    | [] -> failwith "<list_update_elem> index is out of range"
    | h::t -> helper (i-1) (current::l1) h t
  in 
    match lst with 
    | [] -> failwith "<list_update_elem> lst is empty"
    | h::t -> helper i [] h t

(* update [inter_list] to add settlement for player [color] at [point] of type [settl_type]  *)
let add_settlement point color settl_type inter_list = 
  list_update_elem point (Some (color, settl_type)) inter_list

(* update [road_list] to add road on [line] for player [color]  *)
let add_road line color road_list = (color, line)::road_list

(* returns number of towns on the board *)
let num_towns inter_list =
  let f x = (not (is_none x)) && (snd (get_some x) = Town) in 
  list_count f inter_list

(* returns number of cities on the board *)
let num_cities inter_list =
  let f x = (not (is_none x)) && (snd (get_some x) = City) in 
  list_count f inter_list

(* true iff a line exist between p1 and p2 *)
let is_valid_line (p1, p2) = List.length (List.filter (fun x -> x = p2) (adjacent_points p1)) = 1

(* true iff p1 is at least two roads away from any other settlement and p1 does not have a settlement*)
let is_valid_town inter_list p1 = 
  let rec helper = function 
    | [] -> true
    | h::t -> is_none (List.nth inter_list h) && helper t
  in
    is_none (List.nth inter_list p1) && helper (adjacent_points p1)

(* = resource1 + resource2 *)
let plus_recources resource1 resource2 = map_cost2 ( + ) resource1 resource2

(* = resource1 - resource2 *)
let subtract_recources resource1 resource2 = map_cost2 ( - ) resource1 resource2

(* return the hexes corresponding to the a pieces in plst *)
let get_hexes_from_pieces (plst : piece list) (hlst : hex list): hex list = 
  let rec helper out plst hlst nth = 
    match plst, hlst, nth with 
    | [], _, _ -> out
    | ph::pt, hh::ht, n -> begin
      if ph = n then helper (hh::out) pt ht (n+1) 
      else helper out plst ht (n+1)
    end
    | _ -> failwith "<get_hexes_from_pieces> entries in plst don't map to entries in hlst"  
  in 
    helper [] (List.sort (compare) plst) hlst 0

(* return the intersections corresponding to the a pieces in plst *)
let get_intersections_from_points (plst : point list) (ilst : intersection list): intersection list = 
  let rec helper out plst ilst nth = 
    match plst, ilst, nth with 
    | [], _, _ -> out
    | ph::pt, hh::ht, n -> begin
      if ph = n then helper (hh::out) pt ht (n+1) 
      else helper out plst ht (n+1)
    end
    | _ -> failwith "<get_hexes_from_pieces> entries in plst don't map to entries in ilst"  
  in 
    helper [] (List.sort (compare) plst) ilst 0

(* gen num amount of resources from given hex or zero resources if tar = Desert *)
let gen_hex_resource (num : int) ((tar, _) : hex)  = 
  let res = resource_of_terrain tar in 
  if is_none res then (0,0,0,0,0)
  else map_cost (fun x-> x *num ) (single_resource_cost (get_some res))

(* return the sum of num amount of resources generated by each hex 
  that's neighbors p and not occupied by robber *)
let gen_all_resources p num hex_list robber = 
  let adj = List.filter (fun x -> x <> robber) (adjacent_pieces p) in
  let hexes = get_hexes_from_pieces adj hex_list in 
  let f acc elem = plus_recources acc (gen_hex_resource num elem) in
  List.fold_left f (0,0,0,0,0) hexes  

(* add resources r to the inventory of player c *)
let add_resources_to_player c r player_list = 
  let f ((color, (inventory, cards), trophies) as pl) = 
    if color = c then ((color, (plus_recources inventory r, cards), trophies)) else pl
  in
    List.map f player_list 

let random_resource_type () = match Random.int 5 with 
    | 0 -> Brick | 1 -> Wool | 2-> Ore | 3-> Grain | _-> Lumber



(* return a random single resource cost of a resource from inventory.
   if inventory is empty, return (0,0,0,0,0)  *)
let get_a_resource_from inventory = 
  if sum_cost inventory = 0 then (0,0,0,0,0) 
  else begin
    let rec helper () = 
      let res = random_resource_type () in
      if num_resource_in_inventory inventory res > 0 then single_resource_cost res
      else helper ()
    in
      helper () 
  end

(* return a random single resource cost of a resource that this player has. 
  If player's inventory is empty return (0,0,0,0,0)  *)
let get_single_avaliable_resource (color, (inventory, cards), trophies) = 
  get_a_resource_from inventory

(* steal a resource from player c1 and give it to player c2. 
  If c1 has empty inventory then pl is returned unchanged *)
let steal_from_and_give_to c1 c2 pl =  
  let rec steal l1 l2 = match l2 with 
    | [] -> failwith "<steal_from_and_give_to> c1 is not a member of pl"
    | ((color, (inventory, cards), trophies) as p)::t ->  begin
      if color <> c1 then steal (p::l1) t
      else (
        let stolen = get_single_avaliable_resource p in 
        let new_p = (color, (subtract_recources inventory stolen, cards), trophies) 
        in
          ((new_p::l1) @ l2, stolen) 
      )
    end
  in 
    let rec give l1 l2 stolen = match l2 with 
    | [] -> failwith "<steal_from_and_give_to> c2 is not a member of pl"
    | ((color, (inventory, cards), trophies) as p)::t ->  begin
      if color <> c2 then give (p::l1) t stolen
      else (
        let new_p = (color, (plus_recources inventory stolen, cards), trophies) 
        in(new_p::l1) @ l2
      )
    end
  in 
    let (intermidate_pl, stolen) = steal [] pl 
  in 
    give [] intermidate_pl stolen


(* true iff player c has a settlement neighboring piece p*)
let has_settlement_around_piece p c inter_list = 
  let f x = (not (is_none x)) && (fst (get_some x) = c) in 
  list_count f (get_intersections_from_points (piece_corners p) inter_list) > 0
  
(* computes (total inventory)/2 - (total cost). *)
let is_floor_half (color, (inventory, cards), trophies) cost = 
  sum_cost (inventory)/2 - sum_cost(cost)

(* true iff player's inventory is greater than the max hand size a player can have
 before needing to discard when the robber is activated *)
let needs_to_discard (color, (inventory, cards), trophies) = 
  sum_cost inventory > cMAX_HAND_SIZE

(* true iff the player has enough resources in their inventory to cover cost *)
let has_enough_resources (color, (inventory, cards), trophies) cost = 
  let (d1,d2,d3,d4,d5) = subtract_recources inventory cost in 
    d1 >=0 && d2 >=0 && d3 >=0 && d4 >=0 && d5 >=0

(* check if inventory can cover cost, and that cost is floor half of inventory 
  return new olayer with update inventory, and also return the modified cost.
  if cost was not modified then return cost *)
let check_and_fix_discard_move ((color, (inventory, cards), trophies) as pl) cost : player * cost = 
  let new_inventory, new_cost =
    if has_enough_resources pl cost && (is_floor_half pl cost = 0) 
    then (subtract_recources inventory cost, cost)
    else begin
      let rec helper remain cost = 
        if is_floor_half pl cost = 0 then (remain, cost)
        else 
          let single = get_a_resource_from remain in 
          helper (subtract_recources remain single) (plus_recources cost single)
      in  
      let half = map_cost (fun x -> x /2) inventory in
      helper (subtract_recources inventory half) (half)
    end
  in 
    ((color, (new_inventory, cards), trophies), new_cost)  
