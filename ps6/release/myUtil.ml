open Definition
open Constant
open Util

(* set element at index i to e. preserves order of list*)
let list_update_elem (i : int) (e : 'a) (lst : 'a list) : 'a list = 
  let rec helper i l1 current l2 = 
    if i = 0 then List.rev_append l1 (e::l2)
    else match l2 with 
    | [] -> failwith "<list_update_elem> index is out of range"
    | h::t -> helper (i-1) (current::l1) h t
  in 
    match lst with 
    | [] -> failwith "<list_update_elem> lst is empty"
    | h::t -> helper i [] h t

(* update [inter_list] to add settlement for player [color] at [point] of type [settl_type]  *)
let add_settlement point color settl_type inter_list = 
  list_update_elem point (Some (color, settl_type)) inter_list

(* update [road_list] to add road on [line] for player [color]  *)
let add_road line color road_list = (color, line)::road_list

(* returns number of towns on the board *)
let num_towns inter_list =
  let f x = (not (is_none x)) && (snd (get_some x) = Town) in 
  list_count f inter_list

(* returns number of cities on the board *)
let num_cities inter_list =
  let f x = (not (is_none x)) && (snd (get_some x) = City) in 
  list_count f inter_list

(* true iff a line exist between p1 and p2 *)
let is_valid_line (p1, p2) = List.length (List.filter (fun x -> x = p2) (adjacent_points p1)) = 1

(* true iff p1 is at least two roads away from any other settlement and p1 does not have a settlement*)
let is_valid_town inter_list p1 = 
  let rec helper = function 
    | [] -> true
    | h::t -> is_none (List.nth inter_list h) && helper t
  in
    is_none (List.nth inter_list p1) && helper (adjacent_points p1)

(* add two resources *)
let plus_recources resource1 resource2 = map_cost2 ( + ) resource1 resource2

(* return the hexes corresponding to the a pieces in plst *)
let get_hexes_from_pieces (plst : piece list) (hlst : hex list): hex list = 
  let rec helper out plst hlst nth = 
    match plst, hlst, nth with 
    | [], _, _ -> out
    | ph::pt, hh::ht, n -> begin
      if ph = n then helper (hh::out) pt ht (n+1) 
      else helper out plst ht (n+1)
    end
    | _ -> failwith "<get_hexes_from_pieces> entries in plst don't map to entries in hlst"  
  in 
    helper [] (List.sort (compare) plst) hlst 0

(* return the intersections corresponding to the a pieces in plst *)
let get_intersections_from_points (plst : point list) (ilst : intersection list): intersection list = 
  let rec helper out plst ilst nth = 
    match plst, ilst, nth with 
    | [], _, _ -> out
    | ph::pt, hh::ht, n -> begin
      if ph = n then helper (hh::out) pt ht (n+1) 
      else helper out plst ht (n+1)
    end
    | _ -> failwith "<get_hexes_from_pieces> entries in plst don't map to entries in ilst"  
  in 
    helper [] (List.sort (compare) plst) ilst 0

(* gen num amount of resources from given hex or zero resources if tar = Desert *)
let gen_hex_resource (num : int) ((tar, _) : hex)  = 
  let res = resource_of_terrain tar in 
  if is_none res then (0,0,0,0,0)
  else map_cost (fun x-> x *num ) (single_resource_cost (get_some res))

(* return the sum of num amount of resources generated by each hex 
  that's neighbors p and not occupied by robber *)
let gen_all_resources p num hex_list robber = 
  let adj = List.filter (fun x -> x <> robber) (adjacent_pieces p) in
  let hexes = get_hexes_from_pieces adj hex_list in 
  let f acc elem = plus_recources acc (gen_hex_resource num elem) in
  List.fold_left f (0,0,0,0,0) hexes  

(* add resources r to the inventory of player c *)
let add_resources_to_player c r player_list = 
  let f ((color, (inventory, cards), trophies) as pl) = 
    if color = c then ((color, (plus_recources inventory r, cards), trophies)) else pl
  in
    List.map f player_list 

let random_resource_type () = match Random.int 5 with 
    | 0 -> Brick | 1 -> Wool | 2-> Ore | 3-> Grain | _-> Lumber

(* return a random single resource cost of a resource that this player has. 
  If player's inventory is empty return (0,0,0,0,0)  *)
let get_single_avliable_resource (color, (inventory, cards), trophies) = 
  if sum_cost inventory = 0 then (0,0,0,0,0) 
  else begin
    let rec helper () = 
      let res = random_resource_type () in
      if num_resource_in_inventory inventory res > 0 then single_resource_cost res
      else helper ()
    in
      helper () 
  end

(* steal a resource from player c1 and give it to player c2. 
  If c1 has empty inventory then pl is returned unchanged *)
let steal_from_and_give_to c1 c2 pl =  
  let rec steal l1 l2 = match l2 with 
    | [] -> failwith "<steal_from_and_give_to> c1 is not a member of pl"
    | ((color, (inventory, cards), trophies) as p)::t ->  begin
      if color <> c1 then steal (p::l1) t
      else (
        let stolen = get_single_avliable_resource p in 
        let new_p = (color, (plus_recources inventory (map_cost (fun x -> (-1) * x) stolen), cards), trophies) 
        in
          ((new_p::l1) @ l2, stolen) 
      )
    end
  in 
    let rec give l1 l2 stolen = match l2 with 
    | [] -> failwith "<steal_from_and_give_to> c2 is not a member of pl"
    | ((color, (inventory, cards), trophies) as p)::t ->  begin
      if color <> c2 then give (p::l1) t stolen
      else (
        let new_p = (color, (plus_recources inventory stolen, cards), trophies) 
        in(new_p::l1) @ l2
      )
    end
  in 
    let (intermidate_pl, stolen) = steal [] pl 
  in 
    give [] intermidate_pl stolen


(* true iff player c has a settlement neighboring piece p*)
let has_settlement_around_piece p c inter_list = 
  let f x = (not (is_none x)) && (fst (get_some x) = c) in 
  list_count f (get_intersections_from_points (piece_corners p) inter_list) > 0
  
